## 树

### 树的定义

- 树是n（n>=0)个结点的有限集
  1. 若n=0，称为空树
  2. 若n>0，则它满足如下两个条件：
     - 有且只有一个特定的称为**根**的结点
     - 其余结点可分为m(m>=0)互不相交的有限集T1,T2,T3……，Tm,其中每个集合本身又是一棵树，并称为根的子树

### 树的基本术语

1. 根结点：非空树中无前驱结点的结点

2. 结点的度：结点拥有的子树数

3. 树的度：树内各结点的度的最大值

   - 度！=0 **分支结点 非终端结点**

     根结点以外的分支结点称为**内部结点**

   - 度=0  **叶子  终端结点**    

4. 孩子，双亲：结点的子树的根称为该结点的孩子，该结点称为孩子的双亲

5. 兄弟：有共同双亲

6. 堂兄弟：双亲在同一结点

7. 结点的祖先：从根到该结点所经分支的所有结点

8. 结点的子孙：以某结点为根的子树中的任一结点

9. 树的深度：树中结点的最大层次

10. 有序树：树中结点的各子树从左到右有次序(最左边的为第一个孩子)

11. 无序树：树中结点的各子树无次序

12. 森林：是m（m>=0)棵互不相交的树的集合

    ​            把根结点删除树就变成了森林

    ​            一棵树可以看成一个特殊的森林

    ​            给森林中的各子树加上一个双亲结点，森林就变成了树

    ​            **树一定是森林，森林不一定是树**


| 线性结构                    | 树结构                                |
| --------------------------- | ------------------------------------- |
| 第一个数据元素无前驱        | 根结点（只有一个）无双亲              |
| 最后一个数据元素无后继      | 叶子结点（可以有多个）无孩子          |
| 其他元素 一个前驱，一个后继 | 其他结点-中心结点  一个双亲，多个孩子 |
| 一对一                      | 一对多                                |

### 二叉树

#### 二叉树的定义

二叉树是n(n>=0)个结点的有限集，它或者是空集（n=0),或者由一个根结点及两棵互不相交的分别称作这个根的左子树和右子树的二叉树组成

##### 特点

1. 每个结点最多有俩孩子（二叉树中不存在度大于2的结点)
2. 子树有左右之分，其次序不能颠倒
3. 二叉树可以是空集合，根可以有空的左子树或空的右子树

注

- 二叉树不是树的特殊情况，它们是两个概念

- 二叉树结点的子树要区分左子树和右子树，即使只有一颗子树也要区分，说明它是左子树，还是右子树

- 树当结点只有一个孩子时，就无须区分它是左还是右的次序。因此，二者是不同的。这是二叉树与树的最主要的差别。

- (也就是二叉树每个结点位置或者说次序都是固定的，可以是空，但是不可以说它没有位置，而树的结点位置是相对于别的结点来说的，没有别的结点时，它就无所谓左右了)

- 二叉树的5种基本形态

  空二叉树

  根和空的左右子树

  根和左子树

  根和右子树

  根和左右子树

  注:虽然二叉树与树概念不同，但有关树的基本术语对二叉树都适用。

### 树和二叉树的抽象数据类型

#### 树和二叉树的抽象数据类型定义

```c++
ADT BinaryTree{
数据对象D:D是具有相同特性的数据元素的集合。
数据关系R:若D=∅，则R=∅ ;
若D≠∅中，则R= {H};H是如下二元关系:
1.root唯一//关于根的说明
2.Dj∩Dx= ∅//关于子树不相交的说明
3.//关于数据元素的说明
4.//关于左子树和右子树的说明
基本操作P:
}ADT BinaryTree
```

- CreateBiTree(&T,definition)
  初始条件;definition给出二叉树T的定义。
  操作结果:按definition构造二叉树T。

- PreOrderTraverse(T)
  初始条件:二叉树T存在。
  操作结果:先序遍历T，对每个结点访问一次。

- lnOrderTraverse(T)
  初始条件:二叉树T存在。
  操作结果:中序遍历T，对每个结点访问一次。

- PostOrderTraverse(T)
  初始条件:二叉树T存在。
  操作结果:后序遍历T，对每个结点访问一次。

### 二叉树的性质和存储结构

- 性质1:在二叉树的第i层上至多有2^i-1^个结点(i≥1)。

证:采用归纳法证明此性质。
归纳基:当i=1时，只有一个根结点，2^i-1^=2^0^ = 1，命题成立。

归纳假设:设对所有的j(1≤j<i)，命题成立，即第j层上至多
有2^j-1^个结点。那么可以证明j=i时命题也成立。

归纳证明:由归纳假设司知，第i-1层上至多有2^i-2^个结点。
由于二叉树每个结点的度最大为2，故在第i层上最大结点数为第i-1层上最大结点数的2倍，即:
2×2^i-2^=2^i-1^。证毕。

- 性质2:深度为k的二叉树至多有2^k-1^个结点(k ≥1)。

证:由性质1可知，深度为k的二叉树的最大结点数为:
= 2^0^+2^1^+......+2^k-l^
= 2^k^-1

- 性质3:对任何一棵二叉树T，如果其叶子数为no，度为2的结点数为n~2~，则n~0~= n~2~+1。

#### 两种特殊形式的二叉树

- 满二叉树

- 完全二叉树

  满二叉树一定是完全二叉树

  完全二叉树不一定是满二叉树

##### 满二叉树

- —棵深度为k且有2^k-1^个结点的二叉树称为满二叉树。

特点:1.每一层上的结点数都是最大结点数（即每层都满)

​         2.叶子节点全部在最底层

对满二叉树结点位置进行编号

编号规则:

1. 从根结点开始，自上而下，自左而右。
2. 每一结点位置都有元素。

- 满二叉树在同样深度的二叉树中结点个数最多

- 满二叉树在同样深度的二叉树中叶子结点个数最多

##### 完全二叉树

- 深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号为1~n的结点——对应时，称之为完全二叉树。

注:在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树，**一定是连续的去掉!!**

特点:1.叶子只可能分布在层次最大的两层上。
2.对任一结点，如果其右子树的最大层次为i，则其左子树的最大层次必为i或i＋1。

- 性质4:具有n个结点的完全二叉树的深度为|log2n|+1。
  注:|x|:称作x的底，表示不大于x的最大整数

性质4表明了完全二叉树结点数n与完全二叉树深度k之间的关系

性质5:)如果对一棵有n个结点的完全二叉树(深度|logzn|+ 1）结点按层序编号(从第1层到第|logn+1|层，每层从左到右)，则对任一结点i(1≤i≤n)，有:
(1）如果i=1，则结点i是二叉树的根，无双亲;

​        如果i>1，则其双亲是结点|i/ 2|。
(2）如果2i> n，则结点i为叶子结点，无左孩子;

​       否则，其左孩子是结点2i。
(3）如果2i+1 > n，则结点i无右孩，

​      否则，其右孩子是结点2i+1。

性质5表明了完全二叉树中双亲结点编号与孩子结点编号之间的关系

#### 存储结构

##### 二叉树的顺序存储

实现:按满二叉树的结点层次编号，依次存放二叉树中的数据元素。

```c++
//二叉树顺序存储表示
#define MAXTSIZE 100
Typedef TElemType SqBiTree[MAXSTIZE]
SqBiTree bt;
```

特点:
结点间关系蕴含在其存储位置中
浪费空间，适于存满二叉树和完全二叉树

##### 二叉链表存储结构

```c++
typedef struct BiNode{
TElemlype data;
struct BiNode *lchild,*rchild;//左右孩子指针
}BiNode,*BiTree;
```

三叉链表

```c++
typedef struct TriTNode{
TelemType data;
struct TriTNode *lchild,*parent,*rchild;
}TriTNode,*TriTree;
```

### 遍历二叉树

**遍历定义——顺着某一条搜索路径巡访二叉树中的结点，使**
**得每个结点均被访问一次，而且仅被访问一次（又称周游）。**

- “访问”的含义很广，可以是对结点作各种处理，如:输出结点的信
  息、修改结点的数据值等，但要求这种访问不破坏原来的数据结构。

**遍历目的——得到树中所有结点的一个线性排列。**

**遍历用途——它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。**

##### 遍历二叉树算法描述

若规定先左后右，则只有前三种情况:
DLR——先（根）序遍历，
LDR——中(根）序遍历，
LRD———后（根）序遍历。

| 先序遍历二叉树                                               | 中序遍历二叉树<br/>                                          | 后序遍历二叉树<br/>                                          |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 若二叉树为空，则空操作;<br/>否则<br/>(1)访问根结点;<br/>(2)先序遍历左子树;<br/>(3)先序遍历右子树。 | 若二叉树为空，则空操作;<br/>否则<br/>(1)中序遍历左子树;<br/>(2)访问根结点;<br/>(3)中序遍历右子树。 | 若二叉树为空，则空操作;<br/>否则<br/>(1)后序遍历左子树;<br/>(2)后序遍历右子树;<br/>(3)访问根结点。 |

由二叉树的递归定义可知，遍历左子树和遍历右子树可如同遍历二叉树一样“递归”进行。

2.根据遍历序列确定二叉树
若二叉树中各结点的值均不想同，则二叉树结点的先序序列、中序序列和
后序序列都是唯一的。
由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以
确定唯一一棵二叉树

###### 二叉树先序遍历算法

```c++
Status PreOrderTraverse(BiTree T){
  if(T==NULL) return OK;//空二叉树
  else{
  visit(T);//访问根结点
  PreOrderTraverse(T->Ichild);//递归遍历左子树
  PreOrderTraverse(T->rchild);//递归遍历右子树
  }
}    
```

```c++
void Pre(BiTree*T){
if (T!=NULL){
   printf("%d\t",T->data);
   pre(T->lchild);
   pre(T->rchild);
  }
}
```

###### 中序遍历算法

```c++
Status lnOrderTraverse(BiTree T){
  if(T==NULL) return OK;//空二叉树
  else{
  InOrderTraverse(T->lchild);//递归遍历左子树
  visit(T);//访问根结点;
  InOrderTraverse(T->rchild);//递归遍历右子树
  }
}    
```

```c++
Status lnOrderTraverse(BiTree T){//中序
  if(T==NULL)return OK;
  else{
  InOrderTraverse(T->lchild);
  cout<<T->data;
  InOrderTraverse(T->rchild);
  }
}
```



###### 后序遍历算法

```c++
Status PostOrderTraverse(BiTree T){
  if(T==NULL)return OK;//空二叉树
  else{
  PostOrderTraverse(T >lchild);//递归遍历左子树
  PostOrderTraverse(T->rchitd);//递归遍历右子树
  visit(T);//访问根结点
  }
}    
```

```c++
Status PostOrderTraverse(BiTree T){//后序
  if(T==NULL) return OK;
  else{
  PostOrderTraverse(T->lchild);
  PostOrderTraverse(T->rchild);
  cout<<T->data;
  }
}    
```

- 如果去掉输出语句，从递归的角度看，三种算法是完全相同的，或说这三种算法的访问路径是相同的，只是访问结点的时机不同。

###### 遍历二叉树的非递归算法

中序遍历非递归算法
二叉树中序遍历的非递归算法的关键:在中序遍历过某结点的整个左子树后，如何找到该结点的根以及右子树。
基本思想:
(1）建立一个栈
(2）根结点进栈，遍历左子树
(3）根结点出栈，输出根结点，遍历右子树。

```c++
Status lnOrderTraverse (BiTreeT) {
  BiTree p; InitStack(S);p=T;
  while(p || !StackEmpty(S)) {
  if(p){ Push(S,p);p = p->lchild;}
  else { Pop(S,q);printf(“%c”，q->data);
        p= q->rchild;}
  }//while
return OK;
}
```

二叉树层次遍历

- 对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序
  访问每一个结点。

- 每一个结点仅仅访问一次。

- 算法设计思路:

  使用一个队列
  l:将根结点进队;
  Il.队不空时循环:从队列中出列一个结点*p，访问它;
  若它有左孩子结点，将左孩子结点进队;
  若它有右孩子结点，将右孩子结点进队。

使用队列类型定义如下:

```c++
typedef struct{
  BTNode data[MaxSize];//存放队中元素
  int front，rear;//队头和队尾指针
} SqQueue;//顺序循环队列类型
```

```c++
void LevelOrder(BTNode *b){
  BTNode *p;sqQueue *qu;
  InitQueue(qu);//初始化队列
  enQueue(qu，b);//根结点指针进入队列
  while (!QueueEmpty(qu)) {//队不为空，则循环
    deQueue(qu，p);//出队结点p
    printf(" %c "，p->data);//访问结点p
    if(p->Ichild!=NULL) enQueue(qu，p->lchild);//有左孩子时将其进队
    if (p->rchild!=NULL) enQueue(qu，p->rchild);//有右孩子时将其进队
  }
}
```

###### 创建二叉树

```c++
Status CreateBiTree(BiTree &T){
  scanf(&ch);//cin> >ch;
  if (ch== “#”）T= NULL;
  else {
  if ((T = (BiTNode *)malloc(sizeof(BiTNode))))
    exit(OVERFLOW);//T=new BiTNode;
  T->data = ch;/生成根结点
  CreateBiTree(T->lchild);1/构造左子树
  CreateBiTree(T->rchild);/构造右子树
  }
  return OK;
}//CreateBiTree
```

###### 复制二叉树

如果是空树，递归结束;
否则，申请新结点空间，复制根结点

递归复制左子树

递归复制右子树

```c++
int Copy(BiTree T，BiTree &NewT){
  if(T==NULL){/如果是空树返回0
      NewT=NULL; return O;
   }
  else {
      NewT=new BiTNode;NewT->data=T->data;
      Copy(T->lChild，NewT->lchild);
      Copy(T->rChild，NewT->rchild);
}}
```

###### 计算二叉树深度

如果是空树，则深度为0;
否则，递归计算左子树的深度记为m，递归计算右子树的深度记为n,二叉树的深度则为m与r的较大者加1。

```c++
int Depth( BiTree D){
  if(T==NULL)return O;//如果是空树返回0
  else {
      m=Depth(T->lChild);
      n =Depth(T->rChild);
      if(m>n) return(m+1);
      else return(n+1);
  }
}    
```

###### 计算二叉树结点总数

如果是空树，则结点个数为0;

否则，结点个数为左子树的结点个数+右子树的结点个数再+1。

```c++
int NodeCount(BiTree T){
  if(T == NULL)
   return o;
  else
   return NodeCount(T->lchild)+NodeCount(T->rchild)+1;
}
```

###### 计算二叉树叶子结点数

如果是空树，则叶子结点个数为0;
否则，为左子树的叶子结点个数+右子树的叶子结点个数。

```c++
int LeadCount(BiTree T){
  if(丁==NULL)/如果是空树返回0
   return o;
  if(T->lchild == NULL &&T->rchild == NULL)
    return 1;//如果是叶子结点返回1
  else
    return LeafCount(T->lchild) +LeafCount(T->rchild);
}
```

#### 线索二叉树

**利用二叉链表中的空指针域:**
如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱;

如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继

——**这种改变指向的指针称为“线索”**
加上了线索的二叉树称为线索二叉树(Threaded Binary Tree)

为区分Irchid和rchild指针到底是指向孩子的指针，还是指向j前驱或者后继的指针，对上叉链表中每个结点增设两个标志域Itag 和rtag，并约定:

- ltag = 0    Ichild 指向该结点的左孩子
- ltag = 1     lchild 指向该结点的前驱
- rtag = 0     rchild 指向该结点的右孩子
- rtag = 1     rchild 指向该结点的后继

```c++
typedef struct BiThrNode{
  int data;
  int Itag,rtag;
  struct BiThrNode *lchild，rchild;
}BiThrNode，*BiThrTree ;
```

#### 树和森林

森林:是m(m≥0)棵互不相交的树的集合。

树(Tree)是n(n≥O)个结点的有限集。若n = 0，称为空树;
若n >0 (1）有且仅有一个特定的称为根(Root)的结点;

​            (2）其余结点可分为m (m≥0)个互不相交的有限集T1，T2,T3,...Tm,

##### **1双亲表示法**

实现:定义结构数组存放树的结点，
        每个结点含两个域:

1. 数据域:存放结点本身信息。
2. 双亲域:指示本结点的双亲结点在数组中的位置。

```c
typedef struct PTNode {
  TEemlype data;
  intparent;//双亲位置域
}PTNode;
```

```c++
#define MAX_TREE_SIZE 100
typedef struct {
  PTNode nodes[MAX_TREE_SIZE];
  int r, n;//根结点的位置和结点个数
}PTree;
```

##### 2.孩子链表

把每个结点的孩子结点排列起来，看成是一个线性表，用单链表存则n个结点有n个孩子链表(叶子的孩子链表为空表)。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组）存储。

孩子结点结构

```c
typedef struct CTNode {
  int child;
  struct CTNode*next;
}*ChildPtr;
```

双亲结点结构

```c
typedef struct {
  TElemType data;
  childPtr  firstchild;//孩子链表头指针
}CTBox;
```

树结构

```c++
typedef struct {
  CTBox nodes[MAX_TREE_SIZE];
  intn,r;//结点数和根结点的位置
}CTree;
```

##### 3孩子兄弟表示法（二叉树表示法，二叉链表表示法)

实现:用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一个兄弟结点

```c++
typedef struct CSNode{
  ElemType data;
  struct CSNode *firstchild,*nextsibling;
}CSNode,*CSTree;
```

##### 树与二叉树的转换

将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操作。

由于树和二叉树都可以用二叉链表作存储结构，则以二叉镞零作媒介可以导出树与二叉树之间的一个对应关系。

##### 森林转换成二叉树(二叉树与多棵树之间的关系)

1. 将各棵树分别转换成二叉树
2. 将每棵树的根结点用线相连
3. 以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构

##### 森林的遍历

将森林看作由三部分构成:
1、森林中第─棵树的根结点;
2．森林中第一棵树的子树森林;
3．森林中其它树构成的森林。

先序遍历:
若森林不空，则

1. 访问森林中第一棵树的根结点;

2. 先序遍历森林中第一棵树的子树森林;

3. 先序遍历森林中（除第一棵树之外)其余树构成的森林。

   **即:依次从左至右对森林中的每一棵树进行先根遍历。**

中序遍历:
若森林不空，则

1. 中序遍历森林中第一棵树的子树森林;

2. 访问森林中第一棵树的根结点;

3. 中序遍历森林中（除第一棵树之外）其余树构成的森林。

   **即:依次从左至右对森林中的每一棵树进行后根遍历。**
